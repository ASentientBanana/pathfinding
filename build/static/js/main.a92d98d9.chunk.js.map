{"version":3,"sources":["components/GridTile/GridTile.tsx","util/Tile.ts","util/Retrace.ts","util/Astar.ts","util/Djikstra.ts","util/Queue.ts","util/BFS.ts","components/Grid/Grid.tsx","App.tsx","reportWebVitals.js","index.js"],"names":["GridTile","tile","saveRef","close","mouseState","isMovingStart","isMovingEnd","moveStartEnd","tileRef","createRef","tileId","useRef","y","x","useEffect","resizeTiles","setId","current","f","style","height","width","mouseDownHandler","setWalkable","isStartTile","isEndTile","className","includes","classList","remove","add","id","ref","onClick","onMouseOver","Tile","tileSize","isWalkable","g","h","isVisited","neighbors","previusTile","setTileVisited","setGcost","setHcost","setFCost","setStartTile","setEndTile","this","grid","length","push","retrace","start","end","db","path","reverse","forEach","index","setTimeout","sleep","ms","Promise","res","getHeuristic","tileA","tileB","dx","Math","abs","dy","min","aStar","startNode","endNode","open","closed","updateTile","setTileState","a","peek","undefined","pop","neighborTile","nodes","console","log","djikstra","movementCost","Queue","items","item","shift","bfs","openList","closedList","queue","curNode","neighbor","isEmpty","Heap","require","Grid","props","graph","startTile","endTile","useState","gridStyle","setGridStyle","gridRef","rend","clickable","openHeapAstar","b","openHeapDjikstra","setup","setGrid","col","row","Array","i","j","addNeighbors","setStart","setEnd","error","obsticlePos","tileState","isRedraw","clearTileClass","widthCount","floor","clientWidth","heightCount","clientHeight","display","gridTemplateColumns","gridTemplateRows","gridColumnGap","gridRowGap","addToClosed","filter","t","tileOnClickHandler","fCost","hCost","gCost","innerText","onMouseDown","onMouseLeave","onMouseUp","map","random","fullClear","r","tileC","App","obsticlePositionArray","classDatabase","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a92d98d9.chunk.js","sourcesContent":["import React, {\n  useState,\n  useEffect,\n  createRef,\n  useRef,\n  MutableRefObject,\n} from \"react\";\nimport \"./GridTile.css\";\nimport Tile from \"../../util/Tile\";\ninterface style {\n  backgroundColor: string;\n}\ninterface GridTile {\n  mouseState: any;\n  tile: Tile;\n  isMovingStart: MutableRefObject<boolean>;\n  isMovingEnd: MutableRefObject<boolean>;\n  close: Function;\n  saveRef: Function;\n  moveStartEnd: Function;\n}\nconst GridTile = ({\n  tile,\n  saveRef,\n  close,\n  mouseState,\n  isMovingStart,\n  isMovingEnd,\n  moveStartEnd,\n}: GridTile) => {\n  const tileRef = createRef<HTMLDivElement>();\n  const tileId = useRef<string>(`node-${tile.y}-${tile.x}`);\n  useEffect(() => {\n    resizeTiles();\n    if (tile) tile.setId(tileId.current);\n    if (tileRef.current) saveRef(tileRef, tile);\n  }, [tile.f]);\n  const resizeTiles = () => {\n    if (tileRef.current) {\n      const tile: HTMLDivElement = tileRef.current;\n      tile.style.height = `${25}px`;\n      tile.style.width = `${25}px`;\n    }\n  };\n  const mouseDownHandler = () => {\n    if (isMovingStart.current || isMovingEnd.current)\n      moveStartEnd(tile.x, tile.y);\n    else {\n      tile.setWalkable();\n      close(tile);\n     if(!tile.isStartTile || !tile.isEndTile) {\n       if(tileRef.current?.className.includes('obsticle')){\n        tileRef.current?.classList.remove('obsticle')\n      }else{\n        tileRef.current?.classList.add('obsticle')\n      }\n     }\n    }\n  };\n  return (\n    <div\n      className={`grid-tile `} \n      id={tileId.current}\n      ref={tileRef}\n      onClick={mouseDownHandler}\n      onMouseOver={() => {\n        if (mouseState.current) mouseDownHandler();\n      }}\n    ></div>\n  );\n};\nexport default GridTile;\n","class Tile {\n  x: number;\n  y: number;\n  f: number;\n  g: number;\n  h: number;\n  tileSize: number;\n  id: string;\n  isVisited: boolean;\n  neighbors: Tile[];\n  previusTile: Tile | undefined;\n  isWalkable: boolean;\n  isStartTile: boolean;\n  isEndTile: boolean;\n  constructor(\n    x: number,\n    y: number,\n    tileSize: number = 25,\n    isWalkable: boolean = true,\n    isStartTile: boolean = false,\n    isEndTile: boolean = false\n  ) {\n    this.f = 0;\n    this.g = 0;\n    this.h = 0;\n    this.x = x;\n    this.y = y;\n    this.id = \"\";\n    this.isVisited = false;\n    this.neighbors = [];\n    this.tileSize = tileSize;\n    this.isWalkable = isWalkable;\n    this.isStartTile = isStartTile;\n    this.isEndTile = isEndTile;\n  }\n  addNeighbors(grid: Tile[][]) {\n    if (this.y !== grid.length - 1)   this.neighbors.push(grid[this.y + 1][this.x]);\n    if (this.x !== grid[0].length - 1) this.neighbors.push(grid[this.y][this.x + 1]);\n    if (this.y !== 0) this.neighbors.push(grid[this.y - 1][this.x]);\n    if (this.x !== 0) this.neighbors.push(grid[this.y][this.x - 1]);\n  }\n  setTileVisited = () => (this.isVisited = true);\n  setWalkable = () => (this.isWalkable = !this.isWalkable);\n  setId = (id: string) => (this.id = id);\n  setGcost = (g: number) => (this.g = g);\n  setHcost = (h: number) => (this.h = h);\n  setFCost = () => (this.f = this.g + this.h);\n  setStartTile = () => {\n    if (!this.isEndTile) this.isStartTile = true;\n  };\n  setEndTile = () => {\n    if (!this.isStartTile) this.isEndTile = true;\n  };\n}\nexport default Tile;\n","import Tile from \"./Tile\";\n\nconst retrace = (start: Tile, end: Tile, db: any) => {\n    const colors = {\n    bakgroundMainColor: \"#262b2b\",\n    bakgroundColor: \"#2d3636\",\n    accentGoldColor: \"#eab354\",\n    accentGreyColor: \"#5f787b\",\n    accentGreenColor: \"#66ff66\",\n    accentRedColor: \"#cc2900\",\n  };\n    const path: Tile[] = [];\n    let current: Tile = end;\n    while (current !== start) {\n        path.push(current);\n        if (current.previusTile) current = current.previusTile;\n    }\n    path.push(start);\n    path.reverse();\n    path.forEach((tile: Tile, index: number) => {\n        setTimeout(() => {\n            db[tile.id].classList.add('path')\n        }, 10 * index);\n    });\n};\n\nexport default retrace;","\nimport Tile from \"./Tile\";\nimport retrace from './Retrace'\nimport { MutableRefObject } from \"react\";\nconst sleep = (ms: any) => new Promise((res) => setTimeout(res, ms));\n\nconst aStar = async (\n  startNode: Tile,\n  endNode: Tile,\n  open: any,\n  closed: MutableRefObject<Tile[]>,\n  db: any,\n  updateTile: any,\n  setTileState:Function\n  ) => {\n  if (startNode) open.push(startNode);\n  while (open.nodes.length > 0) {\n    await sleep(1);\n    let current: Tile;\n    current = open.peek();\n    if (!current.isEndTile || !current.isStartTile)\n    setTileState(current,'visited')\n    current.setTileVisited();\n    if (endNode !== undefined && current === endNode) {\n      if (startNode && endNode) retrace(startNode, endNode, db);\n      return;\n    }\n    open.pop();\n    closed.current.push(current);\n    current.neighbors.forEach((neighborTile: Tile) => {\n      if (!closed.current.includes(neighborTile)) {\n        if (neighborTile.g === 0) {\n          neighborTile.setGcost(current.g + 0.5);\n          neighborTile.previusTile = current;\n        } else if (neighborTile.g > current.g + 0.5) {\n          neighborTile.setGcost(current.g + 0.5);\n          neighborTile.previusTile = current;\n        }\n        neighborTile.setHcost(getHeuristic(neighborTile, endNode));\n        neighborTile.setFCost();\n        if (!open.nodes.includes(neighborTile)) {\n          setTileState(neighborTile,'visited')\n          open.push(neighborTile);\n          \n          console.log(closed.current.includes(neighborTile));\n          \n        }\n      }\n    });\n  }\n};\nfunction getHeuristic(tileA: Tile, tileB: Tile) {\n  const D2 = 1.4142135623730951;\n  const dx = Math.abs(tileA.x - tileB.x);\n  const dy = Math.abs(tileA.y - tileB.y);\n  return dx + dy + (D2 - 2) * Math.min(dx, dy);\n  // alternativa\n  // return D * (dx + dy) + (D2 - 2 * D) * Math.min(dx, dy);\n}\n\n\nexport default aStar;\n","import Tile from \"./Tile\";\nimport retrace from './Retrace'\nimport { MutableRefObject } from \"react\";\n\nconst sleep = (ms: any) => new Promise((res) => setTimeout(res, ms));\n\nconst djikstra = async (\n  startNode: Tile,\n  endNode: Tile,\n  open: any,\n  closed: MutableRefObject<Tile[]>,\n  db: any,\n  setTileState:Function\n) => {\n  if (startNode) open.push(startNode);\n\n  while (open.nodes.length > 0) {\n    await sleep(1);\n    let current: Tile;\n    current = open.peek();\n\n    setTileState(current,'visited')\n    current.setTileVisited();\n    if (endNode !== undefined && current === endNode) {\n      if (startNode && endNode) retrace(startNode, endNode, db);\n      return;\n    }\n    open.pop();\n    closed.current.push(current);\n    // eslint-disable-next-line no-loop-func\n    current.neighbors.forEach((tile: Tile) => {\n      if (!closed.current.includes(tile)) {\n        let movementCost: number;\n        movementCost = current.g + 1;\n        if (movementCost < tile.g || !open.nodes.includes(tile)) {\n          setTileState(current,'visiting')\n          tile.g = movementCost;\n          tile.previusTile = current;\n          open.push(tile);\n        }\n      }\n    });\n  }\n};\n\nexport default djikstra;\n","import Tile from \"./Tile\";\n\nclass Queue<T>{\n    items:T[] = [];\n    constructor(){\n        this.items = []\n    }\n     isEmpty() {\n        if(this.items.length === 0) return true;\n        else return false;\n\n    }\n    pop(){\n       return this.items.pop();\n    }\n    push(item:T){\n        this.items.push(item)\n    }\n    shift(){\n        return this.items.shift()\n    }\n\n}\n\n\nexport default Queue;","\nimport Tile from \"./Tile\";\nimport retrace from './Retrace'\nimport Queue from './Queue'\nimport { MutableRefObject } from \"react\";\n\n\nconst sleep = (ms: any) => new Promise((res) => setTimeout(res, ms));\n\nconst bfs = async (\n  startNode: Tile,\n  endNode: Tile,\n  db: any,\n  openList: Tile[],\n  closedList:MutableRefObject<Tile[]>,\n  setTileState:Function\n  ) => {\n  startNode.isVisited = true;\n  const queue = new Queue<Tile>();\n  queue.push(startNode)\n  while (!queue.isEmpty()) {\n    await sleep(1);\n    const curNode: Tile = queue.shift()!;\n   setTileState(curNode,'visited')\n    if (curNode === endNode) {\n      retrace(startNode, endNode, db)\n      break;\n    }\n    curNode.neighbors.forEach(neighbor => {\n      if (!closedList.current.includes(neighbor)) {\n        setTileState(curNode,'visiting')\n        neighbor.isVisited = true;\n        closedList.current.push(neighbor);\n        neighbor.previusTile = curNode;\n        queue.push(neighbor);\n      }\n    })\n  }\n}\n\nexport default bfs; ","import React, { useState, useEffect, createRef, useRef } from \"react\";\nimport GridTile from \"../GridTile/GridTile\";\nimport \"./Grid.css\";\nimport Tile from \"../../util/Tile\";\nimport aStar from \"../../util/Astar\";\nimport djikstra from \"../../util/Djikstra\";\nimport bfs from \"../../util/BFS\";\nimport { moveStartColor } from \"../../util/Utility\";\nconst sleep = (ms: any) => new Promise((res) => setTimeout(res, ms));\n\nconst Heap = require(\"heap\");\n\nconst Grid = (props: any) => {\n\tconst graph = useRef<Tile[][]>();\n\tconst startNode: React.MutableRefObject<Tile | undefined> = props.startTile;\n\tconst endNode: React.MutableRefObject<Tile | undefined> = props.endTile;\n\tconst [gridStyle, setGridStyle] = useState<any>();\n\tconst gridRef = createRef<HTMLDivElement>();\n\tconst db = useRef<any>({});\n\tconst mouseState = useRef(false);\n\tconst isMovingStart = useRef<boolean>(false);\n\tconst isMovingEnd = useRef<boolean>(false);\n\tconst [rend, setRend] = useState<boolean>(false);\n\tconst clickable = useRef<boolean>(false);\n\tconst openHeapAstar = new Heap((a: Tile, b: Tile) => a.f - b.f);\n\tconst openHeapDjikstra = new Heap((a: Tile, b: Tile) => a.g - b.g);\n\tlet openList: Tile[] = [];\n\tconst closed = useRef<Tile[]>([]);\n\n\tuseEffect(() => { setup() }, [graph.current, rend]);\n\tconst setup = async () => {\n\t\tconst [col, row] = setGrid();\n\t\tif (!graph.current) graph.current = new Array(row);\n\t\tif (graph.current) {\n\t\t\tfor (let i = 0; i < row; i++) {\n\t\t\t\tgraph.current[i] = new Array(col);\n\t\t\t\tfor (let j = 0; j < graph.current[i].length; j++) {\n\t\t\t\t\tgraph.current[i][j] = new Tile(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// // adds neighbours and walls\n\t\tawait sleep(500)\n\t\tif (graph.current) {\n\t\t\tfor (let i = 0; i < graph.current.length; i++)\n\t\t\t\tfor (let j = 0; j < graph.current[i].length; j++) {\n\t\t\t\t\tgraph.current[i][j].addNeighbors(graph.current);\n\t\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (graph.current && db.current) {\n\t\t\t\t\tif (!startNode.current) setStart()\n\t\t\t\t\telse setStart(startNode.current.x, startNode.current.y, true)\n\t\t\t\t\tif (!endNode.current) setEnd()\n\t\t\t\t\telse setEnd(endNode.current.x, endNode.current.y, true)\n\t\t\t\t\tconsole.log(endNode);\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} catch (error) { }\n\t\t\tif(props.obsticlePos.current.length > 0){\n\t\t\t\tprops.obsticlePos.current.forEach((tile:Tile)=>{\n\t\t\t\t\ttileState(tile,'obsticle')\n\t\t\t\t\tif(graph.current)closed.current.push(graph.current[tile.y][tile.x])\n\t\t\t\t})\n\t\t\t}\n\t\t\tconsole.log(props.obsticlePos.current.length);\n\t\t}\n\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\tclickable.current = true;\n\n\t};\n\tconst setStart = (x: number = 5, y: number = 5, isRedraw: boolean = false) => {\n\t\ttry {\n\t\t\tif (startNode.current && isRedraw) {\n\t\t\t\tstartNode.current.isEndTile = false;\n\t\t\t\tdb.current[startNode.current.id].classList.remove('startTile')\n\t\t\t}\n\t\t\tstartNode.current = graph.current![y][x]\n\t\t\t\tstartNode.current.isEndTile = true;\n\t\t\t\tdb.current[startNode.current.id].classList.add('startTile')\n\t\t} catch { }\n\n\t\tconsole.log(startNode.current);\n\t}\n\tconst setEnd = (x: number = 5, y: number = 9, isRedraw: boolean = false) => {\n\t\ttry {\n\t\t\tif (endNode.current && isRedraw) {\n\t\t\t\tdb.current[endNode.current.id].classList.remove('endTile')\n\t\t\t\tendNode.current.isEndTile = false;\n\t\t\t}\n\t\t\tendNode.current = graph.current![y][x]\n\t\t\tif (endNode.current) {\n\t\t\t\tdb.current[endNode.current.id].classList.add('endTile')\n\t\t\t\tendNode.current.isEndTile = true;\n\t\t\t}\n\t\t} catch (error) { }\n\t}\n\tconst tileState = (tile: Tile, className: string) => {\n\t\t// .obsticle  .visiting .visited \n\t\tconst x =db.current[tile.id]\n\t\tconsole.log(x.className);\n\t\tx.classList.add(className)\n\t}\n\tconst clearTileClass = (tile:Tile) =>{\n\t\tdb.current[tile.id].className = 'grid-tile'\n\t}\n\tconst setGrid = (): number[] => {\n\t\tif (gridRef.current) {\n\t\t\tconst widthCount: number = Math.floor(gridRef.current.clientWidth / 25);\n\t\t\tconst heightCount: number = Math.floor(gridRef.current.clientHeight / 25);\n\t\t\tsetGridStyle({\n\t\t\t\tdisplay: \"grid\",\n\t\t\t\tgridTemplateColumns: `repeat(${widthCount},25px)`,\n\t\t\t\tgridTemplateRows: `repeat(${heightCount},25px)`,\n\t\t\t\tgridColumnGap: \"0px\",\n\t\t\t\tgridRowGap: \"0px\",\n\t\t\t});\n\t\t\tif (widthCount) {\n\t\t\t\treturn [widthCount, heightCount];\n\t\t\t} else return [20, 20];\n\t\t} else return [20, 20];\n\t};\n\n\tconst addToClosed = (tile: Tile) => {\n\t\tif (closed.current.includes(tile)) {\n\t\t\tclosed.current = closed.current.filter((t: Tile) => tile !== t);\n\t\t} else {\n\t\t\tclosed.current.push(tile);\n\t\t}\n\t};\n\n\tconst saveRef = (ref: React.RefObject<HTMLDivElement>, tile: Tile) => {\n\t\tdb.current[tile.id] = ref.current;\n\t};\n\tconst tileOnClickHandler = (x: number, y: number) => {\n\t\tif (isMovingStart.current) {\n\t\t\tif (startNode.current && graph.current) setStart(x, y, true)\n\t\t} else if (isMovingEnd.current) {\n\t\t\tif (endNode.current && graph.current) setEnd(x, y, true)\n\t\t} else {\n\t\t\tif (graph.current) tileState(graph.current[y][x], 'obsticle')\n\t\t}\n\t\tisMovingStart.current = false;\n\t\tisMovingEnd.current = false;\n\t}\n\tconst updateTile = (\n\t\tid: string,\n\t\tfCost: number,\n\t\thCost: number,\n\t\tgCost: number\n\t) => {\n\t\tdb.current[id].innerText = `f:${fCost} h:${hCost} g:${gCost}`;\n\t};\n\tconst clearBoard = () => {\n\t\tif(graph.current)graph.current.forEach((r,index) => {\n\t\t\tr.forEach((tile:Tile)=>{\n\t\t\t\tif(!tile.isStartTile && !tile.isEndTile) {\n\t\t\t\t\tclearTileClass(tile);\n\t\t\t\t\tclosed.current = closed.current.filter((tileC:Tile)=> tile === tileC)\n\t\t\t\t}else{\n\t\t\t\t\tdb.current[tile.id].classList.remove('path')\n\t\t\t\t\tdb.current[tile.id].classList.remove('visited')\n\t\t\t\t\tdb.current[tile.id].classList.remove('visiting')\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t});\n\t\tclickable.current = true;\n\t};\n\tconst clearBordWithWalls = () => {\n\t\tif(graph.current)graph.current.forEach((r:Tile[]) => {\n\t\t\tr.forEach((tile:Tile)=>{\n\t\t\t\tif(!tile.isStartTile && !tile.isEndTile ) {\n\t\t\t\t\tif(tile.isWalkable){\n\t\t\t\t\t\tclearTileClass(tile);\n\t\t\t\t\t\tclosed.current = closed.current.filter((tileC:Tile)=> tile.isWalkable)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t});\n\t\tclickable.current = true;\n\t}\n\treturn (\n\t\t<div>\n\t\t\t<div\n\t\t\t\tid=\"Grid\"\n\t\t\t\tstyle={gridStyle}\n\t\t\t\tref={gridRef}\n\t\t\t\tonMouseDown={() => {\n\t\t\t\t\tmouseState.current = true;\n\t\t\t\t}}\n\t\t\t\tonMouseLeave={() => (mouseState.current = false)}\n\t\t\t\tonMouseUp={() => (mouseState.current = false)}\n\t\t\t>\n\t\t\t\t{graph.current?.map((g: any, i: number) =>\n\t\t\t\t\tg.map((tile: any) => (\n\t\t\t\t\t\t<GridTile\n\t\t\t\t\t\t\tkey={Math.random() * 100000}\n\t\t\t\t\t\t\tmoveStartEnd={tileOnClickHandler}\n\t\t\t\t\t\t\tclose={addToClosed}\n\t\t\t\t\t\t\ttile={tile}\n\t\t\t\t\t\t\tsaveRef={saveRef}\n\t\t\t\t\t\t\tisMovingStart={isMovingStart}\n\t\t\t\t\t\t\tisMovingEnd={isMovingEnd}\n\t\t\t\t\t\t\tmouseState={mouseState}\n\t\t\t\t\t\t/>\n\t\t\t\t\t))\n\t\t\t\t)}\n\t\t\t</div>\n\t\t\t<div className=\"button-tray\">\n\t\t\t\t<div>\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!clickable.current) return;\n\t\t\t\t\t\t\tif (startNode.current && endNode.current) {\n\t\t\t\t\t\t\t\taStar(\n\t\t\t\t\t\t\t\t\tstartNode.current,\n\t\t\t\t\t\t\t\t\tendNode.current,\n\t\t\t\t\t\t\t\t\topenHeapAstar,\n\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\tdb.current,\n\t\t\t\t\t\t\t\t\tupdateTile,\n\t\t\t\t\t\t\t\t\ttileState,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tclickable.current = false;\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\tStart Astar\n      </button>\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tif (!clickable.current) return;\n\t\t\t\t\t\t\tif (startNode.current && endNode.current)\n\t\t\t\t\t\t\t\tdjikstra(\n\t\t\t\t\t\t\t\t\tstartNode.current,\n\t\t\t\t\t\t\t\t\tendNode.current,\n\t\t\t\t\t\t\t\t\topenHeapDjikstra,\n\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\tdb.current,\n\t\t\t\t\t\t\t\t\ttileState\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tclickable.current = false;\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\tDjikstra\n      </button>\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tif (!clickable.current) return;\n\t\t\t\t\t\t\tif (startNode.current && endNode.current) bfs(startNode.current, endNode.current, db.current, openList, closed, tileState)\n\t\t\t\t\t\t\tclickable.current = false;\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\tBFS\n      </button>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\n\t\t\t\t\t<button\n\t\t\t\t\t\tclassName=\"start\"\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tif (!clickable.current) return;\n\t\t\t\t\t\t\tisMovingEnd.current = false;\n\t\t\t\t\t\t\tisMovingStart.current = true;\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\tMove Start Node\n      </button>\n\t\t\t\t\t<button\n\t\t\t\t\t\tclassName=\"end\"\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tif (!clickable.current) return;\n\t\t\t\t\t\t\tisMovingStart.current = false;\n\t\t\t\t\t\t\tisMovingEnd.current = true;\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\tMove End Node\n      </button>\n\t\t\t\t\t<button onClick={()=>{\n\t\t\t\t\t\tprops.fullClear()\n\t\t\t\t\t\tclearBoard()\n\t\t\t\t\t}}>Clear Board</button>\n\t\t\t\t\t{/* <button onClick={()=>{\n\t\t\t\t\t\tclearBordWithWalls()\n\t\t\t\t\t}}>Clear Board Leave Walls</button> */}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\nexport default Grid;\n","import React,{useRef} from 'react';\nimport Grid from './components/Grid/Grid';\nimport Tile from './components/GridTile/GridTile';\nimport './App.css'\nfunction App() {\n  const startNode = useRef<Tile>();\n  const endNode = useRef<Tile>();\n  const obsticlePositionArray = useRef<Tile[]>([])\n  const classDatabase = {}\n  const fullClearboard = ()=> {\n    console.log('test 1');\n    console.log(obsticlePositionArray);\n    obsticlePositionArray.current = []\n    console.log(obsticlePositionArray);\n    console.log('test 2');\n  }\n  \n  return (\n    <div className=\"app\">\n      <Grid startTile ={startNode} endTile={endNode}  obsticlePos={obsticlePositionArray} classDatabase ={classDatabase} fullClear={fullClearboard}/>\n    </div>\n  );\n\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}